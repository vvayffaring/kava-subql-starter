{"version":3,"file":"project.js","sourceRoot":"","sources":["../src/project.ts"],"names":[],"mappings":";AAAA,gEAAgE;AAChE,sCAAsC;;;AAKtC,IAAY,kBAEX;AAFD,WAAY,kBAAkB;IAC5B,8CAAwB,CAAA;AAC1B,CAAC,EAFW,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QAE7B;AAED,IAAY,eAKX;AALD,WAAY,eAAe;IACzB,8CAA2B,CAAA;IAC3B,0DAAuC,CAAA;IACvC,gDAA6B,CAAA;IAC7B,kDAA+B,CAAA;AACjC,CAAC,EALW,eAAe,GAAf,uBAAe,KAAf,uBAAe,QAK1B","sourcesContent":["// Copyright 2020-2022 OnFinality Limited authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport {providers} from 'near-api-js';\nimport {NearBlock, NearTransaction, NearAction, NearTransactionReceipt} from './interfaces';\n\nexport enum NearDatasourceKind {\n  Runtime = 'near/Runtime',\n}\n\nexport enum NearHandlerKind {\n  Block = 'near/BlockHandler',\n  Transaction = 'near/TransactionHandler',\n  Action = 'near/ActionHandler',\n  Receipt = 'near/ReceiptHandler',\n}\n\nexport type RuntimeHandlerInputMap = {\n  [NearHandlerKind.Block]: NearBlock;\n  [NearHandlerKind.Transaction]: NearTransaction;\n  [NearHandlerKind.Action]: NearAction;\n  [NearHandlerKind.Receipt]: NearTransactionReceipt;\n};\n\ntype RuntimeFilterMap = {\n  [NearHandlerKind.Block]: NearBlockFilter;\n  [NearHandlerKind.Transaction]: NearTransactionFilter;\n  [NearHandlerKind.Action]: NearActionFilter;\n  [NearHandlerKind.Receipt]: NearTransactionFilter;\n};\n\nexport interface ProjectManifest {\n  specVersion: string;\n  description: string;\n  repository: string;\n\n  schema: string;\n\n  network: {\n    endpoint: string;\n  };\n\n  dataSources: NearDatasource[];\n  bypassBlocks?: number[];\n}\n\n// [startSpecVersion?, endSpecVersion?] closed range\nexport type SpecVersionRange = [number, number];\n\nexport interface NearBlockFilter {\n  modulo?: number;\n  timestamp?: string;\n}\n\nexport interface NearTransactionFilter {\n  sender?: string;\n  receiver?: string;\n}\n\nexport interface NearReceiptFilter extends NearTransactionFilter {\n  //For Action Receipts:\n  signer?: string;\n}\n\nexport interface NearActionFilter extends NearReceiptFilter {\n  type: string;\n\n  //FunctionCall\n  methodName?: string;\n  args?: string;\n\n  // Stake, AddKey, DeleteKey\n  publicKey?: string;\n\n  // AddKey\n  accessKey?: string;\n\n  // DeleteAccount\n  beneficiaryId?: string;\n}\n\nexport type NearBlockHandler = NearCustomHandler<NearHandlerKind.Block, NearBlockFilter>;\nexport type NearTransactionHandler = NearCustomHandler<NearHandlerKind.Transaction, NearTransactionFilter>;\nexport type NearActionHandler = NearCustomHandler<NearHandlerKind.Action, NearActionFilter>;\nexport type NearReceiptHandler = NearCustomHandler<NearHandlerKind.Receipt, NearTransactionFilter>;\nexport interface NearCustomHandler<K extends string = string, F = Record<string, unknown>> {\n  handler: string;\n  kind: K;\n  filter?: F;\n}\n\nexport type NearRuntimeHandler = NearBlockHandler | NearTransactionHandler | NearActionHandler | NearReceiptHandler;\nexport type NearHandler = NearRuntimeHandler | NearCustomHandler<string, unknown>;\nexport type NearRuntimeHandlerFilter = NearBlockFilter | NearTransactionFilter | NearActionFilter;\n\nexport interface NearMapping<T extends NearHandler = NearHandler> extends FileReference {\n  handlers: T[];\n}\n\ninterface INearDatasource<M extends NearMapping, F extends NearNetworkFilter = NearNetworkFilter> {\n  name?: string;\n  kind: string;\n  filter?: F;\n  startBlock?: number;\n  mapping: M;\n}\n\nexport interface NearRuntimeDatasource<M extends NearMapping<NearRuntimeHandler> = NearMapping<NearRuntimeHandler>>\n  extends INearDatasource<M> {\n  kind: NearDatasourceKind.Runtime;\n}\n\nexport interface NearNetworkFilter {\n  specName?: string;\n}\n\nexport type NearDatasource = NearRuntimeDatasource | NearCustomDatasource; // | NearBuiltinDataSource;\n\nexport interface FileReference {\n  file: string;\n}\n\nexport type CustomDataSourceAsset = FileReference;\n\nexport type Processor<O = any> = FileReference & {options?: O};\n\nexport interface NearCustomDatasource<\n  K extends string = string,\n  T extends NearNetworkFilter = NearNetworkFilter,\n  M extends NearMapping = NearMapping<NearCustomHandler>,\n  O = any\n> extends INearDatasource<M, T> {\n  kind: K;\n  assets: Map<string, CustomDataSourceAsset>;\n  processor: Processor<O>;\n}\n\n//export type NearBuiltinDataSource = INearDatasource;\n\nexport interface HandlerInputTransformer_0_0_0<\n  T extends NearHandlerKind,\n  E,\n  DS extends NearCustomDatasource = NearCustomDatasource\n> {\n  (\n    input: RuntimeHandlerInputMap[T],\n    ds: DS,\n    api: providers.JsonRpcProvider,\n    assets?: Record<string, string>\n  ): Promise<E>; //  | NearBuiltinDataSource\n}\n\nexport interface HandlerInputTransformer_1_0_0<\n  T extends NearHandlerKind,\n  F,\n  E,\n  DS extends NearCustomDatasource = NearCustomDatasource\n> {\n  (params: {\n    input: RuntimeHandlerInputMap[T];\n    ds: DS;\n    filter?: F;\n    api: providers.JsonRpcProvider;\n    assets?: Record<string, string>;\n  }): Promise<E[]>; //  | NearBuiltinDataSource\n}\n\ntype SecondLayerHandlerProcessorArray<\n  K extends string,\n  F extends NearNetworkFilter,\n  T,\n  DS extends NearCustomDatasource<K, F> = NearCustomDatasource<K, F>\n> =\n  | SecondLayerHandlerProcessor<NearHandlerKind.Block, F, T, DS>\n  | SecondLayerHandlerProcessor<NearHandlerKind.Transaction, F, T, DS>\n  | SecondLayerHandlerProcessor<NearHandlerKind.Action, F, T, DS>\n  | SecondLayerHandlerProcessor<NearHandlerKind.Receipt, F, T, DS>;\n\nexport interface NearDatasourceProcessor<\n  K extends string,\n  F extends NearNetworkFilter,\n  DS extends NearCustomDatasource<K, F> = NearCustomDatasource<K, F>,\n  P extends Record<string, SecondLayerHandlerProcessorArray<K, F, any, DS>> = Record<\n    string,\n    SecondLayerHandlerProcessorArray<K, F, any, DS>\n  >\n> {\n  kind: K;\n  validate(ds: DS, assets: Record<string, string>): void;\n  dsFilterProcessor(ds: DS, api: providers.JsonRpcProvider): boolean;\n  handlerProcessors: P;\n}\n\nexport interface DictionaryQueryCondition {\n  field: string;\n  value: string;\n  matcher?: string; // defaults to \"equalTo\", use \"contains\" for JSON\n}\n\nexport interface DictionaryQueryEntry {\n  entity: string;\n  conditions: DictionaryQueryCondition[];\n}\n\ninterface SecondLayerHandlerProcessorBase<\n  K extends NearHandlerKind,\n  F,\n  DS extends NearCustomDatasource = NearCustomDatasource\n> {\n  baseHandlerKind: K;\n  baseFilter: RuntimeFilterMap[K] | RuntimeFilterMap[K][];\n  filterValidator: (filter?: F) => void;\n  dictionaryQuery?: (filter: F, ds: DS) => DictionaryQueryEntry | undefined;\n}\n\n// only allow one custom handler for each baseHandler kind\nexport interface SecondLayerHandlerProcessor_0_0_0<\n  K extends NearHandlerKind,\n  F,\n  E,\n  DS extends NearCustomDatasource = NearCustomDatasource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: undefined;\n  transformer: HandlerInputTransformer_0_0_0<K, E, DS>;\n  filterProcessor: (filter: F | undefined, input: RuntimeHandlerInputMap[K], ds: DS) => boolean;\n}\n\nexport interface SecondLayerHandlerProcessor_1_0_0<\n  K extends NearHandlerKind,\n  F,\n  E,\n  DS extends NearCustomDatasource = NearCustomDatasource\n> extends SecondLayerHandlerProcessorBase<K, F, DS> {\n  specVersion: '1.0.0';\n  transformer: HandlerInputTransformer_1_0_0<K, F, E, DS>;\n  filterProcessor: (params: {filter: F | undefined; input: RuntimeHandlerInputMap[K]; ds: DS}) => boolean;\n}\n\nexport type SecondLayerHandlerProcessor<\n  K extends NearHandlerKind,\n  F,\n  E,\n  DS extends NearCustomDatasource = NearCustomDatasource\n> = SecondLayerHandlerProcessor_0_0_0<K, F, E, DS> | SecondLayerHandlerProcessor_1_0_0<K, F, E, DS>;\n"]}