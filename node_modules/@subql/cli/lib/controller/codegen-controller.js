"use strict";
// Copyright 2020-2022 OnFinality Limited authors & contributors
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateDatasourceTemplates = exports.generateModels = exports.validateEntityName = exports.codegen = exports.processFields = exports.generateAbis = exports.generateEnums = exports.generateJsonInterfaces = exports.renderTemplate = void 0;
const tslib_1 = require("tslib");
const fs_1 = tslib_1.__importDefault(require("fs"));
const path_1 = tslib_1.__importDefault(require("path"));
const util_1 = require("util");
const common_1 = require("@subql/common");
const common_avalanche_1 = require("@subql/common-avalanche");
const common_cosmos_1 = require("@subql/common-cosmos");
const common_ethereum_1 = require("@subql/common-ethereum");
const common_near_1 = require("@subql/common-near");
const common_substrate_1 = require("@subql/common-substrate");
const common_terra_1 = require("@subql/common-terra");
const utils_1 = require("@subql/utils");
const ejs_1 = tslib_1.__importDefault(require("ejs"));
const lodash_1 = require("lodash");
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const typechain_1 = require("typechain");
const MODEL_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/model.ts.ejs');
const MODELS_INDEX_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/models-index.ts.ejs');
const TYPES_INDEX_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/types-index.ts.ejs');
const INTERFACE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/interface.ts.ejs');
const ABI_INTERFACE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/abi-interface.ts.ejs');
const ENUM_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/enum.ts.ejs');
const DYNAMIC_DATASOURCE_TEMPLATE_PATH = path_1.default.resolve(__dirname, '../template/datasource-templates.ts.ejs');
const TYPE_ROOT_DIR = 'src/types';
const MODEL_ROOT_DIR = 'src/types/models';
const ABI_INTERFACES_ROOT_DIR = 'src/types/abi-interfaces';
const CONTRACTS_DIR = 'src/types/contracts'; //generated
const TYPECHAIN_TARGET = 'ethers-v5';
const RESERVED_KEYS = ['filter', 'filters'];
const exportTypes = {
    models: false,
    interfaces: false,
    enums: false,
    datasources: false,
};
// 4. Render entity data in ejs template and write it
async function renderTemplate(templatePath, outputPath, templateData) {
    const data = await ejs_1.default.renderFile(templatePath, templateData);
    await fs_1.default.promises.writeFile(outputPath, data);
}
exports.renderTemplate = renderTemplate;
async function generateJsonInterfaces(projectPath, schema) {
    const typesDir = path_1.default.join(projectPath, TYPE_ROOT_DIR);
    const jsonObjects = (0, utils_1.getAllJsonObjects)(schema);
    const jsonInterfaces = jsonObjects.map((r) => {
        const object = (0, utils_1.setJsonObjectType)(r, jsonObjects);
        const fields = processFields('jsonField', object.name, object.fields);
        return {
            interfaceName: object.name,
            fields,
        };
    });
    if (jsonInterfaces.length !== 0) {
        const interfaceTemplate = {
            props: {
                jsonInterfaces,
            },
            helper: {
                upperFirst: lodash_1.upperFirst,
            },
        };
        try {
            await renderTemplate(INTERFACE_TEMPLATE_PATH, path_1.default.join(typesDir, `interfaces.ts`), interfaceTemplate);
            exportTypes.interfaces = true;
        }
        catch (e) {
            throw new Error(`When render json interfaces having problems.`);
        }
    }
}
exports.generateJsonInterfaces = generateJsonInterfaces;
async function generateEnums(projectPath, schema) {
    const typesDir = path_1.default.join(projectPath, TYPE_ROOT_DIR);
    const jsonObjects = (0, utils_1.getAllEnums)(schema);
    const enums = jsonObjects.map((r) => {
        return {
            name: r.name,
            values: r.getValues().map((v) => v.name),
        };
    });
    if (enums.length !== 0) {
        const enumsTemplate = {
            props: {
                enums,
            },
        };
        try {
            await renderTemplate(ENUM_TEMPLATE_PATH, path_1.default.join(typesDir, `enums.ts`), enumsTemplate);
            exportTypes.enums = true;
        }
        catch (e) {
            throw new Error(`When render enums having problems.`);
        }
    }
}
exports.generateEnums = generateEnums;
async function generateAbis(datasources, projectPath) {
    const sortedAssets = new Map();
    datasources.map((d) => {
        if (!(d === null || d === void 0 ? void 0 : d.assets)) {
            return;
        }
        if ((0, common_ethereum_1.isRuntimeDs)(d) || (0, common_ethereum_1.isCustomDs)(d) || (0, common_substrate_1.isCustomDs)(d)) {
            Object.entries(d.assets).map(([name, value]) => {
                const filePath = path_1.default.join(projectPath, value.file);
                if (!fs_1.default.existsSync(filePath)) {
                    throw new Error(`Error: Asset ${name}, file ${value.file} does not exist`);
                }
                // We use actual abi file name instead on name provided in assets
                // This is aligning with files in './ethers-contracts'
                sortedAssets.set((0, typechain_1.parseContractPath)(filePath).name, value.file);
            });
        }
    });
    if (sortedAssets.size !== 0) {
        await prepareDirPath(path_1.default.join(projectPath, ABI_INTERFACES_ROOT_DIR), true);
        try {
            const allFiles = (0, typechain_1.glob)(projectPath, [...sortedAssets.values()]);
            // Typechain generate interfaces under CONTRACTS_DIR
            await (0, typechain_1.runTypeChain)({
                cwd: projectPath,
                filesToProcess: allFiles,
                allFiles,
                outDir: CONTRACTS_DIR,
                target: TYPECHAIN_TARGET,
            });
            // Iterate here as we have to make sure type chain generated successful,
            // also avoid duplicate generate same abi interfaces
            const renderAbiJobs = processAbis(sortedAssets, projectPath);
            await Promise.all(renderAbiJobs.map((renderProps) => {
                console.log(`* Abi Interface ${renderProps.name} generated`);
                return renderTemplate(ABI_INTERFACE_TEMPLATE_PATH, path_1.default.join(projectPath, ABI_INTERFACES_ROOT_DIR, `${renderProps.name}.ts`), {
                    props: { abi: renderProps },
                    helper: { upperFirst: lodash_1.upperFirst },
                });
            }));
        }
        catch (e) {
            console.error(`! Unable to generate abi interface. ${e.message}`);
        }
    }
}
exports.generateAbis = generateAbis;
function processAbis(sortedAssets, projectPath) {
    const renderInterfaceJobs = [];
    sortedAssets.forEach((value, key) => {
        const renderProps = { name: key, events: [], functions: [] };
        const readAbi = (0, common_1.loadFromJsonOrYaml)(path_1.default.join(projectPath, value));
        // We need to use for loop instead of map, due to events/function name could be duplicate,
        // because they have different input, and following ether typegen rules, name also changed
        // we need to find duplicates, and update its name rather than just unify them.
        const duplicateEventNames = readAbi
            .filter((abiObject) => abiObject.type === 'event')
            .map((obj) => obj.name)
            .filter((name, index, arr) => arr.indexOf(name) !== index);
        const duplicateFunctionNames = readAbi
            .filter((abiObject) => abiObject.type === 'function')
            .map((obj) => obj.name)
            .filter((name, index, arr) => arr.indexOf(name) !== index);
        readAbi.map((abiObject) => {
            if (abiObject.type === 'function') {
                let typeName = abiObject.name;
                let functionName = abiObject.name;
                if (duplicateFunctionNames.includes(abiObject.name)) {
                    functionName = `${abiObject.name}(${abiObject.inputs.map((obj) => obj.type.toLowerCase()).join(',')})`;
                    typeName = joinInputAbiName(abiObject);
                }
                renderProps.functions.push({ typeName, functionName });
            }
            if (abiObject.type === 'event') {
                let name = abiObject.name;
                if (duplicateEventNames.includes(abiObject.name)) {
                    name = joinInputAbiName(abiObject);
                }
                renderProps.events.push(name);
            }
        });
        // avoid empty json
        if (!!renderProps.events || !!renderProps.functions) {
            renderInterfaceJobs.push(renderProps);
        }
    });
    return renderInterfaceJobs;
}
function joinInputAbiName(abiObject) {
    // example: "TextChanged_bytes32_string_string_string_Event", Event name/Function type name will be joined in ejs
    const inputToSnake = abiObject.inputs.map((obj) => obj.type.toLowerCase()).join('_');
    return `${abiObject.name}_${inputToSnake}_`;
}
function processFields(type, className, fields, indexFields = []) {
    const fieldList = [];
    for (const field of fields) {
        const injectField = {
            name: field.name,
            required: !field.nullable,
            isArray: field.isArray,
            isEnum: false,
        };
        if (type === 'entity') {
            const [indexed, unique] = indexFields.reduce((acc, indexField) => {
                if (indexField.fields.includes(field.name)) {
                    acc[0] = true;
                    if (indexField.fields.length === 1 && indexField.unique) {
                        acc[1] = true;
                    }
                    else if (indexField.unique === undefined) {
                        acc[1] = false;
                    }
                }
                return acc;
            }, [false, undefined]);
            injectField.indexed = indexed;
            injectField.unique = unique;
        }
        if (field.isEnum) {
            injectField.type = field.type;
            injectField.isEnum = true;
            injectField.isJsonInterface = false;
        }
        else {
            switch (field.type) {
                default: {
                    injectField.type = (0, utils_1.getTypeByScalarName)(field.type).tsType;
                    if (!injectField.type) {
                        throw new Error(`Schema: undefined type "${field.type.toString()}" on field "${field.name}" in "type ${className} @${type}"`);
                    }
                    injectField.isJsonInterface = false;
                    break;
                }
                case 'Json': {
                    if (field.jsonInterface === undefined) {
                        throw new Error(`On field ${field.name} type is Json but json interface is not defined`);
                    }
                    injectField.type = (0, lodash_1.upperFirst)(field.jsonInterface.name);
                    injectField.isJsonInterface = true;
                }
            }
        }
        fieldList.push(injectField);
    }
    return fieldList;
}
exports.processFields = processFields;
async function prepareDirPath(path, recreate) {
    try {
        await (0, util_1.promisify)(rimraf_1.default)(path);
        if (recreate) {
            await fs_1.default.promises.mkdir(path, { recursive: true });
        }
    }
    catch (e) {
        throw new Error(`Failed to prepare ${path}`);
    }
}
//1. Prepare models directory and load schema
async function codegen(projectPath, fileName) {
    const modelDir = path_1.default.join(projectPath, MODEL_ROOT_DIR);
    const interfacesPath = path_1.default.join(projectPath, TYPE_ROOT_DIR, `interfaces.ts`);
    await prepareDirPath(modelDir, true);
    await prepareDirPath(interfacesPath, false);
    const plainManifest = (0, common_1.loadFromJsonOrYaml)((0, common_1.getManifestPath)(projectPath, fileName));
    if (plainManifest.templates && plainManifest.templates.length !== 0) {
        await generateDatasourceTemplates(projectPath, plainManifest.specVersion, plainManifest.templates);
    }
    const schemaPath = (0, common_1.getSchemaPath)(projectPath, fileName);
    await generateAbis(plainManifest.dataSources, projectPath);
    await generateJsonInterfaces(projectPath, schemaPath);
    await generateModels(projectPath, schemaPath);
    await generateEnums(projectPath, schemaPath);
    if (exportTypes.interfaces || exportTypes.models || exportTypes.enums || exportTypes.datasources) {
        try {
            await renderTemplate(TYPES_INDEX_TEMPLATE_PATH, path_1.default.join(projectPath, TYPE_ROOT_DIR, `index.ts`), {
                props: {
                    exportTypes,
                },
            });
        }
        catch (e) {
            throw new Error(`When render index in types having problems.`);
        }
        console.log(`* Types index generated !`);
    }
}
exports.codegen = codegen;
function validateEntityName(name) {
    for (const reservedKey of RESERVED_KEYS) {
        if (name.toLowerCase().endsWith(reservedKey.toLowerCase())) {
            throw new Error(`EntityName: ${name} cannot end with reservedKey: ${reservedKey}`);
        }
    }
    return name;
}
exports.validateEntityName = validateEntityName;
// 2. Loop all entities and render it
async function generateModels(projectPath, schema) {
    const extractEntities = (0, utils_1.getAllEntitiesRelations)(schema);
    for (const entity of extractEntities.models) {
        const baseFolderPath = '.../../base';
        const className = (0, lodash_1.upperFirst)(entity.name);
        const entityName = validateEntityName(entity.name);
        const fields = processFields('entity', className, entity.fields, entity.indexes);
        const importJsonInterfaces = (0, lodash_1.uniq)(fields.filter((field) => field.isJsonInterface).map((f) => f.type));
        const importEnums = fields.filter((field) => field.isEnum).map((f) => f.type);
        const indexedFields = fields.filter((field) => field.indexed && !field.isJsonInterface);
        const modelTemplate = {
            props: {
                baseFolderPath,
                className,
                entityName,
                fields,
                importJsonInterfaces,
                importEnums,
                indexedFields,
            },
            helper: {
                upperFirst: lodash_1.upperFirst,
            },
        };
        try {
            await renderTemplate(MODEL_TEMPLATE_PATH, path_1.default.join(projectPath, MODEL_ROOT_DIR, `${className}.ts`), modelTemplate);
        }
        catch (e) {
            console.error(e);
            throw new Error(`When render entity ${className} to schema having problems.`);
        }
        console.log(`* Schema ${className} generated !`);
    }
    const classNames = extractEntities.models.map((entity) => entity.name);
    if (classNames.length !== 0) {
        try {
            await renderTemplate(MODELS_INDEX_TEMPLATE_PATH, path_1.default.join(projectPath, MODEL_ROOT_DIR, `index.ts`), {
                props: {
                    classNames,
                },
                helper: {
                    upperFirst: lodash_1.upperFirst,
                },
            });
            exportTypes.models = true;
        }
        catch (e) {
            throw new Error(`When render index in models having problems.`);
        }
        console.log(`* Models index generated !`);
    }
}
exports.generateModels = generateModels;
async function generateDatasourceTemplates(projectPath, specVersion, templates) {
    const props = templates.map((t) => ({
        name: t.name,
        args: hasParameters(t) ? 'Record<string, unknown>' : undefined,
    }));
    try {
        await renderTemplate(DYNAMIC_DATASOURCE_TEMPLATE_PATH, path_1.default.join(projectPath, TYPE_ROOT_DIR, `datasources.ts`), {
            props,
        });
        exportTypes.datasources = true;
    }
    catch (e) {
        console.error(e);
        throw new Error(`Unable to generate datasource template constructors`);
    }
    console.log(`* Datasource template constructors generated !`);
}
exports.generateDatasourceTemplates = generateDatasourceTemplates;
function hasParameters(t) {
    return ((0, common_avalanche_1.isRuntimeDs)(t) ||
        (0, common_avalanche_1.isCustomDs)(t) ||
        (0, common_cosmos_1.isRuntimeCosmosDs)(t) ||
        (0, common_cosmos_1.isCustomCosmosDs)(t) ||
        (0, common_ethereum_1.isRuntimeDs)(t) ||
        (0, common_ethereum_1.isCustomDs)(t) ||
        (0, common_substrate_1.isCustomDs)(t) ||
        (0, common_terra_1.isRuntimeTerraDs)(t) ||
        (0, common_terra_1.isCustomTerraDs)(t) ||
        (0, common_near_1.isRuntimeDs)(t) ||
        (0, common_near_1.isCustomDs)(t));
}
//# sourceMappingURL=codegen-controller.js.map